// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// ============================ VERSION_1.1.0 ==============================
//   ██       ██████  ████████ ████████    ██      ██ ███    ██ ██   ██
//   ██      ██    ██    ██       ██       ██      ██ ████   ██ ██  ██
//   ██      ██    ██    ██       ██       ██      ██ ██ ██  ██ █████
//   ██      ██    ██    ██       ██       ██      ██ ██  ██ ██ ██  ██
//   ███████  ██████     ██       ██    ██ ███████ ██ ██   ████ ██   ██    
// ======================================================================
//  ================ Open source smart contract on EVM =================
//   ============== Verify Random Function by ChainLink ===============

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

import "./IPowerNFT.sol";
import "../RNC/RNC.sol";
import "../CommissionContract/ICommissionCont.sol";
import "./DataStorage.sol";

/**
 * This contract mints NFT by receiving value and holds (value - commission).
 * every round of time a random number will be generated by chainlinke VRF
 * and it could be id of an NFT (by _chance % possibility).
 * selected token balance = selected token value * power
 * owner of the token can withdraw the balance of token.
 * after withdrawing the balance, the token will be burened.
 * commissions will be sent to upgradeable contract powered by LOTTLINK peer-to
 * -peer advertisement system. commission will be shared between refferals.
 * owner of the contract will be changed to LOTT-DAO in the next updates. 
 */
contract PowerNFT is IPowerNFT, ERC721, ERC721URIStorage, Ownable, DataStorage, RNC {

    event RollDice(bytes32 requestId);
    event Win(uint256 tokenId, uint256 amount);


    constructor() ERC721("PowerNFT", "PWR") {
        commissionAddr = 0x6aAd5a41f93Ff379624678f052f395C82294E53d;   //Commission Contract version 1 on mumbai

        setVars(
            1 days, //roundTime
            75, //chancePercent
            2, //power
            25 //commissionPercent
        );
    }

    function totalValueLocked() public view returns(uint256) {
        return totalValueLocked_;
    }

    function totalSupply() public view returns(uint256){
        return counter;
    }

    function lastRandom() public view returns(uint256) {
        return randomness;
    }

    function NFTValue(uint256 tokenId) external view returns(uint256) {
        return tokenValue[tokenId];
    }

    function NFTBalance(uint256 tokenId) external view returns(uint256) {
        return tokenBalance[tokenId];
    }

    function setRoundTime(uint256 _roundTime) public onlyOwner {
        _setRoundTime(_roundTime);
    }

    function setChancePercent(uint256 _chancePercent) public onlyOwner {
        _setChancePercent(_chancePercent);
    }

    function setPower(uint256 _power) public onlyOwner {
        _setPower(_power);
    }

    function setCommissionPercent(uint256 _commissionPercent) public onlyOwner {
        _setCommissionPercent(_commissionPercent);
    }


    function setVars(
        uint256 _roundTime,
        uint256 _chancePercent,
        uint256 _power,
        uint256 _commissionPercent
    ) public onlyOwner {
        _setRoundTime(_roundTime);
        _setChancePercent(_chancePercent);
        _setPower(_power);
        _setCommissionPercent(_commissionPercent);
    }


    function buyCard(string memory uri, address refferal, uint256 dappId) external payable {
        _collectValue(msg.value, refferal, dappId);
        _mintToken(uri, msg.value);
    }


    function rollDice() public roundTimePassed{
        bytes32 requestId = getRandomNumber();
        emit RollDice(requestId);
    }

    function _select(uint256 _randomness) internal override {
        _setRandomness(_randomness);

        if(_randomness % 100 <= chancePercent) {
            uint256 randResult = _randomness / 100;
            uint256 randId = randResult % counter + 1;
            uint256 amount = power * tokenValue[randId];
            _selectToken(randId);
            _setTokenBalance(randId, amount);
            emit Win(randId, amount);
        } else {
            _selectToken(0);
        }
    }


    function burnAndWithdraw(uint256 tokenId) public {
        address payable recipient = payable(ownerOf(tokenId));
        require(recipient == msg.sender, "you can not withdraw this token's balance");
        uint256 amount = tokenBalance[tokenId];
        totalValueLocked_ -= amount;
        delete tokenBalance[tokenId];
        _burn(tokenId);
        recipient.transfer(amount);
    }



////// internal functions //////

    modifier roundTimePassed() {
        require(block.timestamp >= deadLine, "you have to wait untill deadline pass");
        _;
    }

    function _collectValue(uint256 _value, address _refferal, uint256 _dappId) internal {
        uint256 rncFee = applicantFee();
        _value = _value - rncFee;

        swap_MATIC_LINK677(rncFee);

        uint256 commission = _value * commissionPercent / 100;

        if(_value > commission) {
            _value -= commission;
            ICommissionCont(commissionAddr).payCommission{value : commission}(_refferal, _dappId);
        }

        _lockValue(_value); 
    }

    function _mintToken(string memory _uri, uint256 _value) internal {
        uint256 tokenId = _nextTokenId();
        _safeMint(msg.sender, tokenId);
        _setTokenURI(tokenId, _uri);
        _setTokenValue(tokenId, _value);
    }


    function _nextTokenId() internal returns(uint256) {
        _increment();
        return freeTokenId == 0 ? counter : freeTokenId; 
    }


    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
        _decrement();
    }

    // The following functions are overrides required by Solidity.

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }
}