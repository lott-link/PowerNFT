// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

// ============================ VERSION_1.1.0 ==============================
//   ██       ██████  ████████ ████████    ██      ██ ███    ██ ██   ██
//   ██      ██    ██    ██       ██       ██      ██ ████   ██ ██  ██
//   ██      ██    ██    ██       ██       ██      ██ ██ ██  ██ █████
//   ██      ██    ██    ██       ██       ██      ██ ██  ██ ██ ██  ██
//   ███████  ██████     ██       ██    ██ ███████ ██ ██   ████ ██   ██    
// ======================================================================
//  ================ Open source smart contract on EVM =================
//   ============== Verify Random Function by ChainLink ===============

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

import "../RNC/IRNC.sol";
import "../CommissionContract/ICommissionContract.sol";
import "./DataStorage.sol";

/**
 * This contract mints NFT by receiving value and holds (value - commission).
 * every round of time a random number will be generated by chainlinke VRF
 * and it could be id of an NFT (by 1/(_chance + 1) possibility).
 * selected token prize = selected token value * power
 * prize will be added to the balance of the selected token.
 * owner of the token can withdraw the balance of token.
 * after withdrawing the balance, the token will be burened.
 * commissions will be sent to upgradeable contract powered by LOTTLINK peer-to
 * -peer advertisement system. commission will be shared between refferals.
 * owner of the contract will be changed to LOTT-DAO in the next updates. 
 */
contract PowerNFT is ERC721, ERC721URIStorage, ERC721Burnable, Ownable, DataStorage {

    ICommissionContract commissionContract;
    IRNC RNC;

    event RollDice(bytes32 requestId);


    constructor() ERC721("PowerNFT", "PWR") {
        commissionContAddr = address(0);   //should be changed after commissionContract deployed.
        RNCAddr = 0xd674B940A128C81B9894b4a0Db2B2044acbc2882;  //RNC version 1 on mumbai.
        commissionContract = ICommissionContract(commissionContAddr);
        RNC = IRNC(RNCAddr);
    }



    function buyCard(string memory uri, string memory refferal, uint256 dappId) external payable {
        _collectValue(msg.value, refferal, dappId);
        _mintToken(uri, msg.value);
    }


    function rollDice() public roundTimePassed{
        bytes4 selector = this.select.selector;
        bytes32 requestId = RNC.getRandomNumber{value:RNCWithhold}(selector);
        emit RollDice(requestId);
        _resetRNCWithhold();
    }



    function select(uint256 _randomness) public onlyRNC {
        _setRandomness(_randomness);

        if(_randomness % 100 <= chancePercent) {
            uint256 randResult = _randomness / 100;
            uint256 randId = randResult % counter + 1;
            _selectToken(randId);
        }
    }


    function withdrawAndBurn(uint256 tokenId) public {
        address payable recipient = payable(ownerOf(tokenId));
        require(recipient == msg.sender, "you can not withdraw this token's balance");
        uint256 amount = tokenBalance[tokenId];
        delete tokenBalance[tokenId];
        _burn(tokenId);
        recipient.transfer(amount);
    }


    function totalValue() internal view returns(uint256){}







////// internal functions //////

    modifier roundTimePassed() {
        require(block.timestamp >= deadLine, "you have to wait untill deadline pass");
        _;
    }

    modifier onlyRNC() {
        require(msg.sender == RNCAddr, "caller is not the valid RNC");
        _;
    }

    function _collectValue(uint256 _value, string memory _refferal, uint256 _dappId) internal {
        uint256 available = _deductRNCWithhold(RNC.applicantFee(), _value);

        uint256 commission = _value * commissionPercent / 100;

        if(available > commission) {
            available -= commission;
            commissionContract.buyCard{value : commission}(_refferal, _dappId);
        }

        _lockValue(available); 
    }

    function _mintToken(string memory _uri, uint256 _value) internal {
        uint256 tokenId = _nextTokenId();
        _safeMint(msg.sender, tokenId);
        _setTokenURI(tokenId, _uri);
        _setTokenValue(tokenId, _value);
    }


    function _nextTokenId() internal returns(uint256) {
        _increment();
        return freeTokenId == 0 ? counter : freeTokenId; 
    }


    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
        _decrement();
    }

    // The following functions are overrides required by Solidity.

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }
}